#!/bin/bash

# Script help
runhelp() {
    echo ""
    echo "Usage: mtxchanger -f <changer-device> command SOURCE TARGET [flags]"
    echo ""
    echo "    Prints out a series of mtx commands to perform a range of tape"
    echo "moves, or to swap one range of tapes with another. Will preserve"
    echo "order of tapes, unless requested to reverse their order during the"
    echo "operation. Optionally, you can have this script run the mtx commands"
    echo "rather than just display them."
    echo ""
    echo "ARGUMENTS:"
    echo "  -f <changer-device>"
    echo "      This specifies the tape changer to be passed to the mtx command"
    echo "  command"
    echo "      This can be either 'transfer' or 'swap'. With 'transfer' merely"
    echo "      moving the tapes from the source slots to the target slots, and"
    echo "      'swap' doing the same, but also moving tapes from the target"
    echo "      slots back into the source slots."
    echo "  SOURCE TARGET"
    echo "      Both source and target must be a list of comma separated tape"
    echo "      slot numbers, or slot number ranges."
    echo ""
    echo "FLAGS:"
    echo "  --run"
    echo "      Attempt to run the mtx commands to perform the given command."
    echo "  --quiet | -q"
    echo "      Do not display the command that will be run. This flag only"
    echo "      works when the --run flag is specified."
    echo "  --use-empty | -e"
    echo "      Required when using the swap command. This specifies an empty"
    echo "      tape slot that will be used for swapping tapes between the"
    echo "      source and target slots."
    echo "  --reverse"
    echo "      Reverses tape order while transfering tapes; for the swap"
    echo "      command, it will reverse both source and target tape sets."
    echo "  --reverse-source"
    echo "      Similar to --reverse, but only the source tapes are reversed."
    echo "  --reverse-target"
    echo "      Similar to --reverse, but only the target tapes are reversed.".
    echo ""
}

if [[ -z "$1" || $1 == "-h" || $1 == "--help" || $1 == "help" ]]; then
    runhelp
    exit 0
fi

# Set defaults
default_args() {
    declare -g -A ARGS
    ARGS[CHANGER]=/dev/changer
    ARGS[COMMAND]=
    ARGS[SOURCE]=
    ARGS[TARGET]=
    ARGS[EMPTY_SLOT]=
    ARGS[RUN]=0
    ARGS[QUIET]=0
    ARGS[REV_SOURCE]=0
    ARGS[REV_TARGET]=0
}

# Parse command arguments
parse_args() {
    declare -a NON_FLAGS
    # Parse flag arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
        -f)
            ARGS[CHANGER]="$2"
            shift; shift ;;
        --run)
            ARGS[RUN]=1
            shift ;;
        --quiet|-q)
            ARGS[QUIET]=1
            shift ;;
        --use-empty|-e)
            ARGS[EMPTY_SLOT]="$2"
            shift; shift ;;
        --reverse)
            ARGS[REV_SOURCE]=1
            ARGS[REV_TARGET]=1
            shift ;;
        --reverse-source)
            ARGS[REV_SOURCE]=1
            shift ;;
        --reverse-target)
            ARGS[REV_TARGET]=1
            shift ;;
        *)
            NON_FLAGS+=("$1")
            shift ;;
        esac
    done

    # Parse non-flag arguments
    ARGS[COMMAND]=${NON_FLAGS[0]}
    ARGS[SOURCE]=${NON_FLAGS[1]}
    ARGS[TARGET]=${NON_FLAGS[2]}
    # If additional arguments exists, error and exit
    if [[ ! -z ${NON_FLAGS[3]} ]]; then
        echo "ERROR: Unknown extra arguments: ${NON_FLAGS[@]:3}"
        exit 1
    fi
}

# Validate args
check_args() {
    # Parse source and target into arrays of slot numbers
    SOURCE_LIST=($( int_csl2list ${ARGS[SOURCE]} ))
    TARGET_LIST=($( int_csl2list ${ARGS[TARGET]} ))
    # Ensure source and target lists have the exact same number of slots
    if [[ ${#SOURCE_LIST[@]} -ne ${#TARGET_LIST[@]} ]]; then
        echo "ERROR: Source and target have differing number of slots. Source: ${#SOURCE_LIST[@]} Target: ${#TARGET_LIST[@]}"
        exit 1
    fi

    # If command is swap, ensure a use-empty slot is set (and valid integer)
    if [[ ${ARGS[COMMAND]} == "swap" && ! ${ARGS[EMPTY_SLOT]} =~ ^[0-9]+$ ]]; then
        echo "ERROR: Swap command given, but empty slot is not set to a valid value. See --use-empty flag."
        exit 1
    fi

    # Throw error if quiet is set and run is not set
    if [[ ${ARGS[QUIET]} -eq 1 && ${ARGS[RUN]} -ne 1 ]]; then
        echo "ERROR: With quiet flag set and run flag not set, there is nothing to do."
        exit 1
    fi
}

###############################
## Convert a single integer range to list of integers
##  $1 -> An integer range (e.g. 3-8) or a simple integer (e.g. 5)
## Prints the expanded list of ingeters generated from the range, or just prints the simple integer passed
int_range2list() {
    # If a simple number passed in, then just print it and return
    if [[ $1 =~ ^[0-9]+$ ]]; then
        echo $1
    elif [[ $1 =~ ^[0-9]+-[0-9]+$ ]]; then
        SPLT=(${1/-/ })
        echo $( seq ${SPLT[0]} 1 ${SPLT[1]} )
    else
        echo "ERROR: Could not parse slot range: $1"
        exit 1
    fi
}

###############################
## Convert a comma separated list of integers and ranges into a single list of integers
##  $1 -> A list of integers and integer ranges, comma separated (e.g. 4,6,9-11)
## Prints a space delimited string of integers in the list, ranges enumerated, results sorted with duplicates removed
int_csl2list() {
    SLOTS=()
    RLIST=(${1//,/ })
    for R in "${RLIST[@]}"; do
        SLOTS+=($( int_range2list $R ))
    done

    # Remove duplicates and sort ascending
    echo $( printf "%d\n" "${SLOTS[@]}" | sort -nu )
}

#NOTES:
# Do not attempt to move/swap slots if the slots numbers are the same (duh)
# On --run, ensure changer device exists
# On move w/ --run, check to make sure target slots are empty first (UNLESS target is part of move)
# On swap w/ --run, check to make sure use-empty slot is actually empty first
# On move, if target has slots also in source, mtx actions must be reordered to prevent conflict


# Start
default_args
parse_args "$@"
check_args


